local MacLib = loadstring(game:HttpGet("https://github.com/biggaboy212/Maclib/releases/latest/download/maclib.txt"))()

local Window = MacLib:Window({
	Title = "Cease n desist.cc",
	Subtitle = "FREE | Planks\nDiscord.gg/4gAkbADxwy",
	Size = UDim2.fromOffset(788, 570),
	DragStyle = 2,
	DisabledWindowControls = {},
	ShowUserInfo = true,
	Keybind = Enum.KeyCode.RightControl,
	AcrylicBlur = true,
})

local globalSettings = {
	UIBlurToggle = Window:GlobalSetting({
		Name = "UI Blur",
		Default = Window:GetAcrylicBlurState(),
		Callback = function(bool)
			Window:SetAcrylicBlurState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Enabled" or "Disabled") .. " UI Blur",
				Lifetime = 5
			})
		end,
	}),
	NotificationToggler = Window:GlobalSetting({
		Name = "Notifications",
		Default = Window:GetNotificationsState(),
		Callback = function(bool)
			Window:SetNotificationsState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Enabled" or "Disabled") .. " Notifications",
				Lifetime = 5
			})
		end,
	}),
    --
	NotificationToggler = Window:GlobalSetting({
		Name = "discord.gg/4gAkbADxwy",
		--Default = Window:GetNotificationsState(),
		Callback = function(bool)
			--Window:SetNotificationsState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Enabled" or "Disabled") .. " discord.gg/4gAkbADxwy",
				Lifetime = 0.0000000000000001
			})
		end,
	}),
    --
	ShowUserInfo = Window:GlobalSetting({
		Name = "Show User Info",
		Default = Window:GetUserInfoState(),
		Callback = function(bool)
			Window:SetUserInfoState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Showing" or "Redacted") .. " User Info",
				Lifetime = 5
			})
		end,
	})
}
--

--
local tabGroups = {
	TabGroup1 = Window:TabGroup()
}

local tabs = {
	Settings = tabGroups.TabGroup1:Tab({ Name = "config", Image = "rbxassetid://10734950309" })
}

MacLib:SetFolder("Cease n desist Planks")
tabs.Settings:InsertConfigSection("Left")

Window.onUnloaded(function()
	print("Unloaded")
end)

local TabGroup = Window:TabGroup()
local GeneralTab = TabGroup:Tab({ Name = "General" })
local RageTab = TabGroup:Tab({ Name = "Rage" })
local TabGroup = Window:TabGroup()
local LightingTab = TabGroup:Tab({ Name = "Lighting" })
local VisualsTab = TabGroup:Tab({ Name = "Visuals" })
local TabGroup = Window:TabGroup()
local ViewmodelTab = TabGroup:Tab({ Name = "Viewmodel" })

local GeneralSection = GeneralTab:Section({ Side = "Left" })
local GeneralColors  = GeneralTab:Section({ Side = "Right" })

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local AimPart = "Head"
local AimbotEnabled = false
local UseFOV = false
local VisualizeFOV = false
local WallCheckEnabled = false
local HealthCheckEnabled = false
local FOVSliderValue = 60
local FOV = 60
local Smoothness = 1
local AimbotKey = Enum.UserInputType.MouseButton2

local screenSize = Camera.ViewportSize
local screenCenter = Vector2.new(screenSize.X / 2, screenSize.Y / 2)

local FOVCircle = Drawing.new("Circle")
FOVCircle.Radius = FOV
FOVCircle.Position = screenCenter
FOVCircle.Color = Color3.fromRGB(255, 221, 51)
FOVCircle.Thickness = 1
FOVCircle.Transparency = 1
FOVCircle.Filled = false
FOVCircle.Visible = false

local HoldingKey = false
UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == AimbotKey or input.KeyCode == AimbotKey then
        HoldingKey = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == AimbotKey or input.KeyCode == AimbotKey then
        HoldingKey = false
    end
end)

local function isEnemy(player)
    if not player.Team or not LocalPlayer.Team then
        return true
    end
    return player.Team ~= LocalPlayer.Team
end

local function isTargetValid(player)
    if not player.Character then return false end
    if not isEnemy(player) then return false end
    if HealthCheckEnabled then
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if not humanoid or humanoid.Health <= 0 then return false end
    end
    local head = player.Character:FindFirstChild(AimPart)
    if not head then return false end
    if WallCheckEnabled then
        local origin = Camera.CFrame.Position
        local direction = (head.Position - origin).Unit * 500
        local ray = Ray.new(origin, direction)
        local hit = workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character})
        if hit and not hit:IsDescendantOf(player.Character) then
            return false
        end
    end
    return true
end

local function getClosestPlayer()
    local closestPlayer = nil
    local closestAngle = math.huge
    local camPos = Camera.CFrame.Position
    local camLook = Camera.CFrame.LookVector
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and isTargetValid(player) then
            local head = player.Character:FindFirstChild(AimPart)
            if head then
                local dir = (head.Position - camPos)
                if dir.Magnitude > 0 then
                    local dot = math.clamp(camLook:Dot(dir.Unit), -1, 1)
                    local angle = math.deg(math.acos(dot))
                    if (not UseFOV or angle <= FOV) and angle < closestAngle then
                        closestAngle = angle
                        closestPlayer = {player = player, position = head.Position}
                    end
                end
            end
        end
    end
    return closestPlayer
end

RunService.RenderStepped:Connect(function()
    screenSize = Camera.ViewportSize
    screenCenter = Vector2.new(screenSize.X / 2, screenSize.Y / 2)
    FOVCircle.Position = screenCenter
    FOV = math.floor(FOVSliderValue + 0.5)
    FOVCircle.Radius = FOV
    FOVCircle.Visible = VisualizeFOV

    if AimbotEnabled and HoldingKey then
        local targetData = getClosestPlayer()
        if targetData then
            local camPos = Camera.CFrame.Position
            local targetPos = targetData.position
            local targetCFrame = CFrame.new(camPos, targetPos)
            local alpha = math.clamp(1 / math.max(Smoothness, 1), 0, 1)
            Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, alpha)
        end
    end
end)

GeneralSection:Toggle({
    Name = "Aimbot",
    Default = false,
    Callback = function(value)
        AimbotEnabled = value
    end,
}, "AimbotToggle")

GeneralSection:Toggle({
    Name = "Use FOV",
    Default = false,
    Callback = function(value)
        UseFOV = value
    end,
}, "UseFOVToggle")

GeneralSection:Toggle({
    Name = "Visualize FOV",
    Default = false,
    Callback = function(value)
        VisualizeFOV = value
    end,
}, "VisualizeFOVToggle")

GeneralSection:Toggle({
    Name = "WallCheck",
    Default = false,
    Callback = function(value)
        WallCheckEnabled = value
    end,
}, "WallCheckToggle")

GeneralSection:Toggle({
    Name = "HealthCheck",
    Default = false,
    Callback = function(value)
        HealthCheckEnabled = value
    end,
}, "HealthCheckToggle")

GeneralSection:Slider({
    Name = "FOV Radius",
    Default = 60,
    Minimum = 0,
    Maximum = 360,
    DisplayMethod = "Value",
    Callback = function(value)
        FOVSliderValue = value
        FOV = math.floor(value + 0.5)
    end,
}, "FOVRadiusSlider")

GeneralSection:Slider({
    Name = "Smoothness",
    Default = 1,
    Minimum = 1,
    Maximum = 20,
    DisplayMethod = "Value",
    Callback = function(value)
        Smoothness = math.floor(value + 0.5)
    end,
}, "SmoothnessSlider")

GeneralSection:Keybind({
    Name = "Aimbot Keybind",
    Default = Enum.KeyCode.ButtonR2,
    Callback = function(key)
        AimbotKey = key
    end,
}, "AimbotKeybind")

GeneralColors:Colorpicker({
    Name = "FOV Color",
    Default = Color3.fromRGB(255, 221, 51),
    Alpha = 0,
    Callback = function(color, alpha)
        FOVCircle.Color = color
        FOVCircle.Transparency = 1 - alpha
    end,
}, "FOVColorPicker")

local VisualsMain   = VisualsTab:Section({ Side = "Left" })
local VisualsColors = VisualsTab:Section({ Side = "Right" })

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local SkeletonColor = Color3.fromRGB(255, 221, 51)
local Skeletons = {}
local SkeletonEnabled = false

local R6Parts = {
    Head = "Torso",
    LeftArm = "Torso",
    RightArm = "Torso",
    LeftLeg = "Torso",
    RightLeg = "Torso"
}

local R15Parts = {
    Head = "UpperTorso",
    UpperTorso = "LowerTorso",
    LowerTorso = nil,
    LeftUpperArm = "UpperTorso",
    LeftLowerArm = "LeftUpperArm",
    LeftHand = "LeftLowerArm",
    RightUpperArm = "UpperTorso",
    RightLowerArm = "RightUpperArm",
    RightHand = "RightLowerArm",
    LeftUpperLeg = "LowerTorso",
    LeftLowerLeg = "LeftUpperLeg",
    LeftFoot = "LeftLowerLeg",
    RightUpperLeg = "LowerTorso",
    RightLowerLeg = "RightUpperLeg",
    RightFoot = "RightLowerLeg"
}

local function isEnemy(player)
    if not player.Team or not LocalPlayer.Team then
        return true
    end
    return player.Team ~= LocalPlayer.Team
end

local function createSkeleton(player)
    if not isEnemy(player) then return end
    local character = player.Character
    if not character then return end
    removeSkeleton(player)
    local partsTable = character:FindFirstChild("Humanoid") and character.Humanoid.RigType == Enum.HumanoidRigType.R15 and R15Parts or R6Parts
    local lines = {}
    for childName, parentName in pairs(partsTable) do
        local part = character:FindFirstChild(childName)
        local parentPart = parentName and character:FindFirstChild(parentName) or nil
        if part and parentPart then
            local line = Drawing.new("Line")
            line.Color = SkeletonColor
            line.Thickness = 1
            line.Visible = true
            table.insert(lines, {line = line, part1 = part, part2 = parentPart})
        end
    end
    Skeletons[player] = lines
end

function removeSkeleton(player)
    if Skeletons[player] then
        for _, info in ipairs(Skeletons[player]) do
            info.line:Remove()
        end
        Skeletons[player] = nil
    end
end

local function trackPlayer(player)
    player.CharacterAdded:Connect(function()
        if SkeletonEnabled then
            task.wait(1)
            createSkeleton(player)
        end
    end)
end

Players.PlayerAdded:Connect(trackPlayer)
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        trackPlayer(player)
        if player.Character then
            createSkeleton(player)
        end
    end
end

RunService.RenderStepped:Connect(function()
    if not SkeletonEnabled then
        for _, lines in pairs(Skeletons) do
            for _, info in ipairs(lines) do
                info.line.Visible = false
            end
        end
        return
    end
    for player, lines in pairs(Skeletons) do
        if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 and isEnemy(player) then
            for _, info in ipairs(lines) do
                local p1, p2 = info.part1, info.part2
                if p1.Parent and p2.Parent then
                    local p1Pos, p2Pos = Camera:WorldToViewportPoint(p1.Position), Camera:WorldToViewportPoint(p2.Position)
                    info.line.From = Vector2.new(p1Pos.X, p1Pos.Y)
                    info.line.To = Vector2.new(p2Pos.X, p2Pos.Y)
                    info.line.Color = SkeletonColor
                    info.line.Visible = p1Pos.Z > 0 and p2Pos.Z > 0
                else
                    info.line.Visible = false
                end
            end
        else
            removeSkeleton(player)
        end
    end
end)

VisualsColors:Colorpicker({
    Name = "Skeleton Color",
    Default = SkeletonColor,
    Alpha = 0,
    Callback = function(color, alpha)
        SkeletonColor = color
    end,
}, "SkeletonColorPicker")

VisualsMain:Toggle({
    Name = "Skeleton ESP",
    Default = false,
    Callback = function(value)
        SkeletonEnabled = value
        if value then
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    createSkeleton(player)
                end
            end
        else
            for _, player in ipairs(Players:GetPlayers()) do
                removeSkeleton(player)
            end
        end
    end,
}, "SkeletonESPToggle")

--
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local espBoxes, espCorners = {}, {}
local boxEnabled, cornerEnabled = false, false
local boxColor, cornerColor = Color3.fromRGB(255, 221, 51), Color3.fromRGB(255, 221, 51)

local function isEnemy(player)
    return not player.Team or not LocalPlayer.Team or player.Team ~= LocalPlayer.Team
end

local function getCorners(part)
    local cframe = part.CFrame
    local size = part.Size / 2
    return {
        cframe * Vector3.new(-size.X, -size.Y, -size.Z),
        cframe * Vector3.new(-size.X, -size.Y, size.Z),
        cframe * Vector3.new(-size.X, size.Y, -size.Z),
        cframe * Vector3.new(-size.X, size.Y, size.Z),
        cframe * Vector3.new(size.X, -size.Y, -size.Z),
        cframe * Vector3.new(size.X, -size.Y, size.Z),
        cframe * Vector3.new(size.X, size.Y, -size.Z),
        cframe * Vector3.new(size.X, size.Y, size.Z),
    }
end

local function createBox(player)
    if not isEnemy(player) then return end
    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = boxColor
    box.Thickness = 1
    box.Filled = false
    espBoxes[player] = box
end

local function createCornerBox(player)
    if not isEnemy(player) then return end
    local box = {}
    for i = 1, 8 do
        box[i] = Drawing.new("Line")
        box[i].Color = cornerColor
        box[i].Thickness = 1
        box[i].Visible = false
    end
    espCorners[player] = box
end

local function removeBox(player)
    if espBoxes[player] then
        espBoxes[player]:Remove()
        espBoxes[player] = nil
    end
    if espCorners[player] then
        for _, line in ipairs(espCorners[player]) do
            line:Remove()
        end
        espCorners[player] = nil
    end
end

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createBox(player)
        createCornerBox(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    createBox(player)
    createCornerBox(player)
end)

Players.PlayerRemoving:Connect(removeBox)

RunService.RenderStepped:Connect(function()
    for player, box in pairs(espBoxes) do
        local character = player.Character
        if not character or not isEnemy(player) then
            box.Visible = false
            if espCorners[player] then
                for _, line in ipairs(espCorners[player]) do
                    line.Visible = false
                end
            end
            continue
        end

        local minX, minY = math.huge, math.huge
        local maxX, maxY = -math.huge, -math.huge
        local hasOnScreen = false

        for _, part in ipairs(character:GetChildren()) do
            if part:IsA("BasePart") then
                for _, corner in ipairs(getCorners(part)) do
                    local pos, onScreen = Camera:WorldToViewportPoint(corner)
                    if onScreen then
                        hasOnScreen = true
                        minX, minY = math.min(minX, pos.X), math.min(minY, pos.Y)
                        maxX, maxY = math.max(maxX, pos.X), math.max(maxY, pos.Y)
                    end
                end
            end
        end

        if hasOnScreen then
            if boxEnabled then
                box.Position = Vector2.new(minX, minY)
                box.Size = Vector2.new(maxX - minX, maxY - minY)
                box.Color = boxColor
                box.Visible = true
            else
                box.Visible = false
            end

            if cornerEnabled then
                local width, height = maxX - minX, maxY - minY
                local lineLengthX, lineLengthY = width * 0.25, height * 0.25
                local lines = espCorners[player]

                lines[1].From, lines[1].To = Vector2.new(minX, minY), Vector2.new(minX + lineLengthX, minY)
                lines[2].From, lines[2].To = Vector2.new(minX, minY), Vector2.new(minX, minY + lineLengthY)
                lines[3].From, lines[3].To = Vector2.new(maxX, minY), Vector2.new(maxX - lineLengthX, minY)
                lines[4].From, lines[4].To = Vector2.new(maxX, minY), Vector2.new(maxX, minY + lineLengthY)
                lines[5].From, lines[5].To = Vector2.new(minX, maxY), Vector2.new(minX + lineLengthX, maxY)
                lines[6].From, lines[6].To = Vector2.new(minX, maxY), Vector2.new(minX, maxY - lineLengthY)
                lines[7].From, lines[7].To = Vector2.new(maxX, maxY), Vector2.new(maxX - lineLengthX, maxY)
                lines[8].From, lines[8].To = Vector2.new(maxX, maxY), Vector2.new(maxX, maxY - lineLengthY)

                for _, line in ipairs(lines) do
                    line.Color = cornerColor
                    line.Visible = true
                end
            elseif espCorners[player] then
                for _, line in ipairs(espCorners[player]) do
                    line.Visible = false
                end
            end
        else
            box.Visible = false
            if espCorners[player] then
                for _, line in ipairs(espCorners[player]) do
                    line.Visible = false
                end
            end
        end
    end
end)

VisualsMain:Toggle({
    Name = "Box",
    Default = false,
    Callback = function(value)
        boxEnabled = value
    end,
}, "BoxToggle")

VisualsMain:Toggle({
    Name = "Corner Box",
    Default = false,
    Callback = function(value)
        cornerEnabled = value
    end,
}, "CornerBoxToggle")

VisualsColors:Colorpicker({
    Name = "Box Color",
    Default = boxColor,
    Alpha = 0,
    Callback = function(color)
        boxColor = color
    end,
}, "BoxColorPicker")

VisualsColors:Colorpicker({
    Name = "Corner Box Color",
    Default = cornerColor,
    Alpha = 0,
    Callback = function(color)
        cornerColor = color
    end,
}, "CornerBoxColorPicker")

--
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local nameTags = {}
local nameEnabled = false
local nameColor = Color3.fromRGB(255, 221, 51)
local outlineColor = Color3.new(0,0,0)
local scaleMultiplier = 30
local minSize = 12
local maxSize = 18
local defaultSize = 14

local function isEnemy(player)
    if not player.Team or not LocalPlayer.Team then
        return true
    end
    return player.Team ~= LocalPlayer.Team
end

local function createNameTag(player)
    if not isEnemy(player) then return end
    local nameDrawing = Drawing.new("Text")
    nameDrawing.Text = player.Name
    nameDrawing.Color = nameColor
    nameDrawing.Outline = true
    nameDrawing.OutlineColor = outlineColor
    nameDrawing.Size = defaultSize
    nameDrawing.Center = true
    nameDrawing.Visible = false
    nameTags[player] = nameDrawing
end

local function removeNameTag(player)
    if nameTags[player] then
        nameTags[player]:Remove()
        nameTags[player] = nil
    end
end

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createNameTag(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        createNameTag(player)
    end
end)

Players.PlayerRemoving:Connect(removeNameTag)

RunService.RenderStepped:Connect(function()
    for player, tag in pairs(nameTags) do
        if not isEnemy(player) then
            tag.Visible = false
            continue
        end

        local character = player.Character
        if character and character:FindFirstChild("Head") and nameEnabled then
            local head = character.Head
            local pos, onScreen = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 2, 0))
            if onScreen then
                local distance = (Camera.CFrame.Position - head.Position).Magnitude
                local size = math.clamp(scaleMultiplier / distance, minSize, maxSize)
                tag.Size = size
                tag.Position = Vector2.new(pos.X, pos.Y - size)
                tag.Color = nameColor
                tag.Visible = true
            else
                tag.Visible = false
            end
        else
            tag.Visible = false
        end
    end
end)

VisualsMain:Toggle({
    Name = "Name ESP",
    Default = false,
    Callback = function(value)
        nameEnabled = value
    end,
}, "NameEspToggle")

VisualsColors:Colorpicker({
    Name = "Name Color",
    Default = nameColor,
    Alpha = 0,
    Callback = function(color, alpha)
        nameColor = color
    end,
}, "NameColorPicker")

--
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local healthBars = {}
local healthOutlines = {}
local healthEnabled = false

local maxBarWidth = 6
local barOffset = 3
local maxDistance = 100
local minScale = 0.3

local function isEnemy(player)
    if not player.Team or not LocalPlayer.Team then
        return true
    end
    return player.Team ~= LocalPlayer.Team
end

local function createHealthBar(player)
    if not isEnemy(player) then return end
    local bar = Drawing.new("Square")
    bar.Filled = true
    bar.Thickness = 1
    bar.Visible = false
    healthBars[player] = bar

    local outline = Drawing.new("Square")
    outline.Filled = false
    outline.Thickness = 1
    outline.Color = Color3.new(0, 0, 0)
    outline.Visible = false
    healthOutlines[player] = outline
end

local function removeHealthBar(player)
    if healthBars[player] then
        healthBars[player]:Remove()
        healthBars[player] = nil
    end
    if healthOutlines[player] then
        healthOutlines[player]:Remove()
        healthOutlines[player] = nil
    end
end

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createHealthBar(player)
    end
end

Players.PlayerAdded:Connect(createHealthBar)
Players.PlayerRemoving:Connect(removeHealthBar)

local function getCorners(part)
    local cframe = part.CFrame
    local size = part.Size / 2
    return {
        cframe * Vector3.new(-size.X, -size.Y, -size.Z),
        cframe * Vector3.new(-size.X, -size.Y, size.Z),
        cframe * Vector3.new(-size.X, size.Y, -size.Z),
        cframe * Vector3.new(-size.X, size.Y, size.Z),
        cframe * Vector3.new(size.X, -size.Y, -size.Z),
        cframe * Vector3.new(size.X, -size.Y, size.Z),
        cframe * Vector3.new(size.X, size.Y, -size.Z),
        cframe * Vector3.new(size.X, size.Y, size.Z),
    }
end

RunService.RenderStepped:Connect(function()
    for player, bar in pairs(healthBars) do
        if not isEnemy(player) then
            bar.Visible = false
            if healthOutlines[player] then
                healthOutlines[player].Visible = false
            end
            continue
        end

        local character = player.Character
        if character and healthEnabled and character:FindFirstChild("Humanoid") and character.PrimaryPart then
            local humanoid = character.Humanoid
            local minX, minY = math.huge, math.huge
            local maxX, maxY = -math.huge, -math.huge
            local onScreen = false

            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    for _, corner in pairs(getCorners(part)) do
                        local pos, visible = Camera:WorldToViewportPoint(corner)
                        if visible then
                            onScreen = true
                            minX = math.min(minX, pos.X)
                            minY = math.min(minY, pos.Y)
                            maxX = math.max(maxX, pos.X)
                            maxY = math.max(maxY, pos.Y)
                        end
                    end
                end
            end

            if onScreen then
                local healthPercent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
                local boxHeight = maxY - minY

                local distance = (Camera.CFrame.Position - character.PrimaryPart.Position).Magnitude
                local distanceScale = math.clamp(1 - (distance / maxDistance), minScale, 1)
                local barWidth = maxBarWidth * distanceScale
                local barHeight = boxHeight * healthPercent

                local barX = minX - barWidth - barOffset
                local barY = maxY - barHeight

                bar.Position = Vector2.new(barX, barY)
                bar.Size = Vector2.new(barWidth, barHeight)
                bar.Color = Color3.fromRGB(255 * (1 - healthPercent), 255 * healthPercent, 0)
                bar.Visible = true

                local outline = healthOutlines[player]
                outline.Position = Vector2.new(barX - 1, minY)
                outline.Size = Vector2.new(barWidth + 2, boxHeight)
                outline.Visible = true
            else
                bar.Visible = false
                if healthOutlines[player] then
                    healthOutlines[player].Visible = false
                end
            end
        else
            bar.Visible = false
            if healthOutlines[player] then
                healthOutlines[player].Visible = false
            end
        end
    end
end)

VisualsMain:Toggle({
    Name = "Health Bar",
    Default = false,
    Callback = function(value)
        healthEnabled = value
    end,
}, "HealthBarToggle")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local function isEnemy(player)
    if not player.Team or not LocalPlayer.Team then
        return true
    end
    return player.Team ~= LocalPlayer.Team
end

--
local fillBoxes = {}
local fillEnabled = false
local fillColor = Color3.fromRGB(0, 0, 0)
local fillTransparency = 0.4

local function createFillBox(player)
    if not isEnemy(player) then return end
    local fill = Drawing.new("Square")
    fill.Color = fillColor
    fill.Transparency = fillTransparency
    fill.Filled = true
    fill.Visible = false
    fillBoxes[player] = fill
end

local function removeFillBox(player)
    if fillBoxes[player] then
        fillBoxes[player]:Remove()
        fillBoxes[player] = nil
    end
end

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createFillBox(player)
    end
end

Players.PlayerAdded:Connect(createFillBox)
Players.PlayerRemoving:Connect(removeFillBox)

local function getCorners(part)
    local cframe = part.CFrame
    local size = part.Size / 2
    return {
        cframe * Vector3.new(-size.X, -size.Y, -size.Z),
        cframe * Vector3.new(-size.X, -size.Y, size.Z),
        cframe * Vector3.new(-size.X, size.Y, -size.Z),
        cframe * Vector3.new(-size.X, size.Y, size.Z),
        cframe * Vector3.new(size.X, -size.Y, -size.Z),
        cframe * Vector3.new(size.X, -size.Y, size.Z),
        cframe * Vector3.new(size.X, size.Y, -size.Z),
        cframe * Vector3.new(size.X, size.Y, size.Z),
    }
end

RunService.RenderStepped:Connect(function()
    for player, fill in pairs(fillBoxes) do
        local character = player.Character
        if not character or not isEnemy(player) or not fillEnabled then
            fill.Visible = false
            continue
        end

        local minX, minY, maxX, maxY = math.huge, math.huge, -math.huge, -math.huge
        local hasOnScreen = false

        for _, part in ipairs(character:GetChildren()) do
            if part:IsA("BasePart") then
                for _, corner in ipairs(getCorners(part)) do
                    local pos, onScreen = Camera:WorldToViewportPoint(corner)
                    if onScreen then
                        hasOnScreen = true
                        minX, minY = math.min(minX, pos.X), math.min(minY, pos.Y)
                        maxX, maxY = math.max(maxX, pos.X), math.max(maxY, pos.Y)
                    end
                end
            end
        end

        if hasOnScreen then
            fill.Position = Vector2.new(minX, minY)
            fill.Size = Vector2.new(maxX - minX, maxY - minY)
            fill.Color = fillColor
            fill.Transparency = fillTransparency
            fill.Visible = true
        else
            fill.Visible = false
        end
    end
end)

VisualsMain:Toggle({
    Name = "Fill Box",
    Default = false,
    Callback = function(value)
        fillEnabled = value
    end,
}, "FillBoxToggle")

VisualsColors:Colorpicker({
    Name = "Fill Box Color",
    Default = fillColor,
    Alpha = 0,
    Callback = function(color)
        fillColor = color
    end,
}, "FillBoxColorPicker")

local tracers = {}
local tracersEnabled = false
local tracerColor = Color3.fromRGB(255, 221, 51)
local tracerFrom = "Bottom"

local function createTracer(player)
    if not isEnemy(player) then return end
    local line = Drawing.new("Line")
    line.Visible = false
    line.Color = tracerColor
    line.Thickness = 1
    tracers[player] = line
end

local function removeTracer(player)
    if tracers[player] then
        tracers[player]:Remove()
        tracers[player] = nil
    end
end

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createTracer(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    createTracer(player)
end)

Players.PlayerRemoving:Connect(removeTracer)

RunService.RenderStepped:Connect(function()
    local startY = tracerFrom == "Top" and 0 or tracerFrom == "Middle" and Camera.ViewportSize.Y / 2 or Camera.ViewportSize.Y
    local startX = Camera.ViewportSize.X / 2

    for player, line in pairs(tracers) do
        if not isEnemy(player) then
            line.Visible = false
            continue
        end

        local character = player.Character
        if character and character:FindFirstChild("Head") and tracersEnabled then
            local head = character.Head
            local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
            if onScreen then
                line.From = Vector2.new(startX, startY)
                line.To = Vector2.new(screenPos.X, screenPos.Y)
                line.Color = tracerColor
                line.Visible = true
            else
                line.Visible = false
            end
        else
            line.Visible = false
        end
    end
end)

VisualsMain:Toggle({
    Name = "Tracers",
    Default = false,
    Callback = function(value)
        tracersEnabled = value
    end,
}, "TracersToggle")

VisualsColors:Colorpicker({
    Name = "Tracers Color",
    Default = tracerColor,
    Alpha = 0,
    Callback = function(color, alpha)
        tracerColor = color
    end,
}, "TracersColorPicker")

--
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local distanceTags = {}
local distanceEnabled = false
local distanceColor = Color3.fromRGB(255, 221, 51)
local outlineColor = Color3.new(0,0,0)
local scaleMultiplier = 30
local minSize = 12
local maxSize = 18
local defaultSize = 14
local offsetBelowFeet = 3.5

local function isEnemy(player)
    if not player.Team or not LocalPlayer.Team then
        return true
    end
    return player.Team ~= LocalPlayer.Team
end

local function createDistanceTag(player)
    if not isEnemy(player) then return end
    local distanceDrawing = Drawing.new("Text")
    distanceDrawing.Text = ""
    distanceDrawing.Color = distanceColor
    distanceDrawing.Outline = true
    distanceDrawing.OutlineColor = outlineColor
    distanceDrawing.Size = defaultSize
    distanceDrawing.Center = true
    distanceDrawing.Visible = false
    distanceTags[player] = distanceDrawing
end

local function removeDistanceTag(player)
    if distanceTags[player] then
        distanceTags[player]:Remove()
        distanceTags[player] = nil
    end
end

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createDistanceTag(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        createDistanceTag(player)
    end
end)

Players.PlayerRemoving:Connect(removeDistanceTag)

RunService.RenderStepped:Connect(function()
    for player, tag in pairs(distanceTags) do
        if not isEnemy(player) then
            tag.Visible = false
            continue
        end

        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") and distanceEnabled then
            local hrp = character.HumanoidRootPart
            local targetPos = hrp.Position - Vector3.new(0, offsetBelowFeet, 0)
            local pos, onScreen = Camera:WorldToViewportPoint(targetPos)
            if onScreen then
                local distance = math.floor((Camera.CFrame.Position - hrp.Position).Magnitude + 0.5)
                local size = math.clamp(scaleMultiplier / distance, minSize, maxSize)
                tag.Size = size
                tag.Position = Vector2.new(pos.X, pos.Y)
                tag.Text = "Dist [" .. tostring(distance) .. "m]"
                tag.Color = distanceColor
                tag.Visible = true
            else
                tag.Visible = false
            end
        else
            tag.Visible = false
        end
    end
end)

VisualsMain:Toggle({
    Name = "Distance ESP",
    Default = false,
    Callback = function(value)
        distanceEnabled = value
    end,
}, "DistanceEspToggle")

VisualsColors:Colorpicker({
    Name = "Distance Color",
    Default = distanceColor,
    Alpha = 0,
    Callback = function(color, alpha)
        distanceColor = color
    end,
}, "DistanceColorPicker")

local RageSection = RageTab:Section({ Side = "Left" })
local RageSlider = RageTab:Section({ Side = "Right" })

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local NoclipEnabled = false

local originalCollides = {}

local function enableNoclip()
    if not Character then return end
    for _, part in ipairs(Character:GetDescendants()) do
        if part:IsA("BasePart") then
            if originalCollides[part] == nil then
                originalCollides[part] = part.CanCollide
            end
            part.CanCollide = false
        end
    end
end

local function disableNoclip()
    for part, coll in pairs(originalCollides) do
        if part and part.Parent then
            part.CanCollide = coll
        end
    end
    originalCollides = {}
end

RunService.Stepped:Connect(function()
    if NoclipEnabled and Character and Character.Parent then
        enableNoclip()
    end
end)

RageSection:Toggle({
    Name = "Noclip",
    Default = false,
    Callback = function(value)
        NoclipEnabled = value
        if NoclipEnabled then
            enableNoclip()
        else
            disableNoclip()
        end
    end,
}, "NoclipToggle")

LocalPlayer.CharacterAdded:Connect(function(char)
    Character = char
    if NoclipEnabled then
        enableNoclip()
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Humanoid = Character:WaitForChild("Humanoid")

local FlyEnabled = false
local FlySpeed = 50
local BodyVelocity

local keys = {W = false, A = false, S = false, D = false, Space = false, Shift = false}

UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if keys[input.KeyCode.Name] ~= nil then keys[input.KeyCode.Name] = true end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if keys[input.KeyCode.Name] ~= nil then keys[input.KeyCode.Name] = false end
    end
end)

local function getMoveVector()
    local cam = workspace.CurrentCamera
    local dir = Vector3.new()
    if keys.W then dir = dir + cam.CFrame.LookVector end
    if keys.S then dir = dir - cam.CFrame.LookVector end
    if keys.A then dir = dir - cam.CFrame.RightVector end
    if keys.D then dir = dir + cam.CFrame.RightVector end
    if keys.Space then dir = dir + Vector3.new(0,1,0) end
    if keys.Shift then dir = dir - Vector3.new(0,1,0) end
    if dir.Magnitude > 0 then
        return dir.Unit * FlySpeed
    else
        return Vector3.new(0,0,0)
    end
end

local function startFly()
    Humanoid.PlatformStand = true
    BodyVelocity = Instance.new("BodyVelocity")
    BodyVelocity.MaxForce = Vector3.new(1e5,1e5,1e5)
    BodyVelocity.Velocity = Vector3.new(0,0,0)
    BodyVelocity.Parent = HumanoidRootPart

    RunService.RenderStepped:Connect(function()
        if FlyEnabled and BodyVelocity then
            BodyVelocity.Velocity = getMoveVector()
        end
    end)
end

local function stopFly()
    Humanoid.PlatformStand = false
    if BodyVelocity then
        BodyVelocity:Destroy()
        BodyVelocity = nil
    end
end

RageSection:Toggle({
    Name = "Fly",
    Default = false,
    Callback = function(value)
        FlyEnabled = value
        if FlyEnabled then startFly() else stopFly() end
    end,
}, "FlyToggle")

RageSlider:Slider({
    Name = "Fly Speed",
    Default = 50,
    Minimum = 10,
    Maximum = 500,
    DisplayMethod = "Value",
    Callback = function(value)
        FlySpeed = value
    end,
}, "FlySpeedSlider")

LocalPlayer.CharacterAdded:Connect(function(char)
    Character = char
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    Humanoid = Character:WaitForChild("Humanoid")
    if FlyEnabled then startFly() end
end)

RageSlider:Slider({
    Name = "Fire Rate",
    Default = 0.02,
    Minimum = 0.001,
    Maximum = 0.2,
    DisplayMethod = "Value",
    Callback = function(value)
        FireRateValue = value
        if RapidFireEnabled then
            setRapidFire(true)
        end
    end,
}, "FireRateSlider")

local LightingSection = LightingTab:Section({ Side = "Left" })
local LightingColors  = LightingTab:Section({ Side = "Right" })

local Lighting = game:GetService("Lighting")
local originalOutdoorAmbient = Lighting.OutdoorAmbient
local originalDiffuse = Lighting.EnvironmentDiffuseScale
local originalSpecular = Lighting.EnvironmentSpecularScale

LightingSection:Toggle({
	Name = "No Skybox",
	Default = false,
	Callback = function(value)
		if value then
			for _, obj in pairs(Lighting:GetChildren()) do
				if obj:IsA("Sky") then
					obj:Destroy()
				end
			end
			Lighting.OutdoorAmbient = Color3.new(0, 0, 0)
			Lighting.EnvironmentDiffuseScale = 0
			Lighting.EnvironmentSpecularScale = 0
		else
			Lighting.OutdoorAmbient = originalOutdoorAmbient
			Lighting.EnvironmentDiffuseScale = originalDiffuse
			Lighting.EnvironmentSpecularScale = originalSpecular
		end
	end,
}, "NoSkyboxToggle")

local Lighting = game:GetService("Lighting")

local WorldColorEnabled = false
local WorldColor = Color3.fromRGB(255, 255, 255)
local WorldColorIntensity = 1

local function applyWorldColor()
    if WorldColorEnabled then
        Lighting.OutdoorAmbient = Color3.new(
            math.clamp(WorldColor.R * WorldColorIntensity, 0, 1),
            math.clamp(WorldColor.G * WorldColorIntensity, 0, 1),
            math.clamp(WorldColor.B * WorldColorIntensity, 0, 1)
        )
    else
        Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
    end
end

LightingSection:Toggle({
    Name = "World Accent Color",
    Default = false,
    Callback = function(value)
        WorldColorEnabled = value
        applyWorldColor()
    end,
}, "WorldAccentToggle")

LightingColors:Colorpicker({
    Name = "Lighting Color",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 0,
    Callback = function(color, alpha)
        WorldColor = color
        applyWorldColor()
    end,
}, "LightingColorPicker")

LightingSection:Slider({
    Name = "Color Intensity",
    Default = 1,
    Minimum = 0,
    Maximum = 5,
    DisplayMethod = "Multiplier",
    Callback = function(value)
        WorldColorIntensity = value
        applyWorldColor()
    end,
}, "WorldColorIntensitySlider")

local ViewmodelSection = ViewmodelTab:Section({ Side = "Left" })
local ViewmodelColors = ViewmodelTab:Section({ Side = "Right" })

local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local Camera = Workspace.CurrentCamera

local parts = {}
local originalStates = {}
local RainbowForcefieldEnabled = false

local function getRainbowColor(offset)
    return Color3.fromHSV((tick() * 0.2 + offset) % 1, 1, 1)
end

local function applyForceField(part)
    if part.Transparency >= 1 then return end
    if not originalStates[part] then
        originalStates[part] = {
            Material = part.Material,
            Transparency = part.Transparency,
            Color = part.Color
        }
    end
    part.Material = Enum.Material.ForceField
    part.Transparency = 0.3
    table.insert(parts, part)
end

local function resetParts()
    for _, part in ipairs(parts) do
        if originalStates[part] and part.Parent then
            part.Material = originalStates[part].Material
            part.Transparency = originalStates[part].Transparency
            part.Color = originalStates[part].Color
        end
    end
    parts = {}
    originalStates = {}
end

local function refreshParts()
    parts = {}
    for _, part in ipairs(Camera:GetDescendants()) do
        if part:IsA("BasePart") and part.Transparency < 1 then
            applyForceField(part)
            for _, joint in ipairs(part:GetJoints()) do
                if joint.Part0 and joint.Part0:IsA("BasePart") and joint.Part0.Transparency < 1 then
                    applyForceField(joint.Part0)
                end
                if joint.Part1 and joint.Part1:IsA("BasePart") and joint.Part1.Transparency < 1 then
                    applyForceField(joint.Part1)
                end
            end
        end
    end
end

Camera.DescendantAdded:Connect(function(desc)
    if RainbowForcefieldEnabled and desc:IsA("BasePart") and desc.Transparency < 1 then
        applyForceField(desc)
    end
end)

Camera.AncestryChanged:Connect(function(_, parent)
    if RainbowForcefieldEnabled and parent then
        refreshParts()
    end
end)

RunService.RenderStepped:Connect(function()
    if RainbowForcefieldEnabled then
        for i, part in ipairs(parts) do
            if part.Parent then
                part.Color = getRainbowColor(i / #parts)
            end
        end
    end
end)

ViewmodelSection:Toggle({
    Name = "Rainbow Forcefield",
    Default = false,
    Callback = function(value)
        RainbowForcefieldEnabled = value
        if value then
            refreshParts()
        else
            resetParts()
        end
    end,
}, "ForcefieldToggle")

local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local Camera = Workspace.CurrentCamera

local parts = {}
local originalStates = {}
local RainbowForcefieldEnabled = false
local ForcefieldColor = Color3.fromRGB(255, 255, 255)

local function applyForceField(part)
    if part.Transparency >= 1 then return end
    if not originalStates[part] then
        originalStates[part] = {
            Material = part.Material,
            Transparency = part.Transparency,
            Color = part.Color
        }
    end
    part.Material = Enum.Material.ForceField
    part.Transparency = 0.3
    part.Color = ForcefieldColor
    table.insert(parts, part)
end

local function resetParts()
    for _, part in ipairs(parts) do
        if originalStates[part] and part.Parent then
            part.Material = originalStates[part].Material
            part.Transparency = originalStates[part].Transparency
            part.Color = originalStates[part].Color
        end
    end
    parts = {}
    originalStates = {}
end

local function refreshParts()
    parts = {}
    for _, part in ipairs(Camera:GetDescendants()) do
        if part:IsA("BasePart") and part.Transparency < 1 then
            applyForceField(part)
            for _, joint in ipairs(part:GetJoints()) do
                if joint.Part0 and joint.Part0:IsA("BasePart") and joint.Part0.Transparency < 1 then
                    applyForceField(joint.Part0)
                end
                if joint.Part1 and joint.Part1:IsA("BasePart") and joint.Part1.Transparency < 1 then
                    applyForceField(joint.Part1)
                end
            end
        end
    end
end

Camera.DescendantAdded:Connect(function(desc)
    if RainbowForcefieldEnabled and desc:IsA("BasePart") and desc.Transparency < 1 then
        applyForceField(desc)
    end
end)

Camera.AncestryChanged:Connect(function(_, parent)
    if RainbowForcefieldEnabled and parent then
        refreshParts()
    end
end)

RunService.RenderStepped:Connect(function()
    if RainbowForcefieldEnabled then
        for _, part in ipairs(parts) do
            if part.Parent then
                part.Color = ForcefieldColor
            end
        end
    end
end)

ViewmodelSection:Toggle({
    Name = "Rainbow Forcefield",
    Default = false,
    Callback = function(value)
        RainbowForcefieldEnabled = value
        if value then
            refreshParts()
        else
            resetParts()
        end
    end,
}, "ForcefieldToggle")

ViewmodelColors:Colorpicker({
    Name = "Forcefield Color",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 0,
    Callback = function(color, alpha)
        ForcefieldColor = color
        if RainbowForcefieldEnabled then
            for _, part in ipairs(parts) do
                if part.Parent then
                    part.Color = ForcefieldColor
                end
            end
        end
    end,
}, "ForcefieldColorPicker")

local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local Camera = Workspace.CurrentCamera

local parts = {}
local originalStates = {}

local SolidForcefieldEnabled = false
local RainbowForcefieldEnabled = false
local SolidForcefieldColor = Color3.fromRGB(255, 255, 255)

local function getRainbowColor(offset)
    return Color3.fromHSV((tick() * 0.2 + offset) % 1, 1, 1)
end

local function applyPartEffect(part)
    if part.Transparency >= 1 then return end
    if not originalStates[part] then
        originalStates[part] = {
            Material = part.Material,
            Transparency = part.Transparency,
            Color = part.Color
        }
    end
    table.insert(parts, part)
end

local function resetParts()
    for _, part in ipairs(parts) do
        if originalStates[part] and part.Parent then
            part.Material = originalStates[part].Material
            part.Transparency = originalStates[part].Transparency
            part.Color = originalStates[part].Color
        end
    end
    parts = {}
    originalStates = {}
end

local function refreshParts()
    parts = {}
    for _, part in ipairs(Camera:GetDescendants()) do
        if part:IsA("BasePart") and part.Transparency < 1 then
            applyPartEffect(part)
            for _, joint in ipairs(part:GetJoints()) do
                if joint.Part0 and joint.Part0:IsA("BasePart") and joint.Part0.Transparency < 1 then
                    applyPartEffect(joint.Part0)
                end
                if joint.Part1 and joint.Part1:IsA("BasePart") and joint.Part1.Transparency < 1 then
                    applyPartEffect(joint.Part1)
                end
            end
        end
    end
end

Camera.DescendantAdded:Connect(function(desc)
    if (SolidForcefieldEnabled or RainbowForcefieldEnabled) and desc:IsA("BasePart") and desc.Transparency < 1 then
        applyPartEffect(desc)
    end
end)

Camera.AncestryChanged:Connect(function(_, parent)
    if (SolidForcefieldEnabled or RainbowForcefieldEnabled) and parent then
        refreshParts()
    end
end)

RunService.RenderStepped:Connect(function()
    if SolidForcefieldEnabled then
        for _, part in ipairs(parts) do
            if part.Parent then
                part.Material = Enum.Material.SmoothPlastic
                part.Color = SolidForcefieldColor
                part.Transparency = 0
            end
        end
    elseif RainbowForcefieldEnabled then
        for i, part in ipairs(parts) do
            if part.Parent then
                part.Material = Enum.Material.SmoothPlastic
                part.Color = getRainbowColor(i / #parts)
                part.Transparency = 0
            end
        end
    end
end)

ViewmodelSection:Toggle({
    Name = "Solid Color",
    Default = false,
    Callback = function(value)
        SolidForcefieldEnabled = value
        if value then
            RainbowForcefieldEnabled = false
            refreshParts()
        else
            resetParts()
        end
    end,
}, "SolidForcefieldToggle")

ViewmodelSection:Toggle({
    Name = "Rainbow Solid",
    Default = false,
    Callback = function(value)
        RainbowForcefieldEnabled = value
        if value then
            SolidForcefieldEnabled = false
            refreshParts()
        else
            resetParts()
        end
    end,
}, "RainbowForcefieldToggle")

ViewmodelColors:Colorpicker({
    Name = "Solid Color Picker",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 0,
    Callback = function(color, alpha)
        SolidForcefieldColor = color
        if SolidForcefieldEnabled then
            for _, part in ipairs(parts) do
                if part.Parent then
                    part.Color = SolidForcefieldColor
                end
            end
        end
    end,
}, "SolidForcefieldColorPicker")

tabs.Settings:Select()
MacLib:LoadAutoLoadConfig() 
